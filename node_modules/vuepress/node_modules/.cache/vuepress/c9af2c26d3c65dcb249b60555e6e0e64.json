{"remainingRequest":"/home/bingyu/vue/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/home/bingyu/vue/node_modules/cache-loader/dist/cjs.js??ref--1-0!/home/bingyu/vue/node_modules/vue-loader/lib/index.js??ref--1-1!/home/bingyu/vue/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/home/bingyu/vue/docs/3-Linux/3-2-Shell.md?vue&type=template&id=6344a681&","dependencies":[{"path":"/home/bingyu/vue/docs/3-Linux/3-2-Shell.md","mtime":1549619620543},{"path":"/home/bingyu/vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"shell编程\\\"><a href=\\\"#shell编程\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Shell编程</h1> <h2 id=\\\"概述\\\"><a href=\\\"#概述\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 概述</h2> <p>常用的shell有Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh), 各有优缺点。Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p> <blockquote><p>此处学习的为bash shell</p></blockquote> <h2 id=\\\"shell脚本的实质\\\"><a href=\\\"#shell脚本的实质\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> shell脚本的实质</h2> <ul><li>shell脚本语言是解释型语言</li> <li>shell脚本的实质-shell命令的有序集合</li></ul> <h2 id=\\\"为什么要使用-filename-sh-行shell脚本呢？\\\"><a href=\\\"#为什么要使用-filename-sh-行shell脚本呢？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 为什么要使用 <code>./filename.sh</code> 行shell脚本呢？</h2> <p>普通的shell命令会从标准路径中进行查询，可以通过 echo $PATH 来查询，如果从这些标准路径中查询不到命令，那么就认为是错误的，即是提示命令找不到。所以需要使用 ./</p> <h2 id=\\\"shell变量\\\"><a href=\\\"#shell变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> shell变量</h2> <p>shell允许用户建立变量存储数据，但不支持数据类型(整型、字符、浮点型)，将任何赋给变量的值都解释为一串字符。\\n以$开头的字符在shell中会被解释为变量。\\n<strong>细节问题</strong>：</p> <ol><li>没有类型</li> <li>没有空格作为分隔符(与C语言不同，C语言对空格不做任何编译)，即&quot;count = 1&quot;为错误的。赋值的时候等号的两边都没有空格。\\ne.g.</li></ol> <div class=\\\"language-bash extra-class\\\"><pre class=\\\"language-bash\\\"><code>count<span class=\\\"token operator\\\">=</span>1\\n<span class=\\\"token keyword\\\">echo</span> <span class=\\\"token variable\\\">$count</span>\\nDATE<span class=\\\"token operator\\\">=</span><span class=\\\"token string\\\">'date'</span>\\n<span class=\\\"token keyword\\\">echo</span> <span class=\\\"token variable\\\">$DATE</span>\\n</code></pre></div><p>shell有以下4种变量：</p> <ul><li>用户自定义变量</li> <li>位置变量即命令行参数</li> <li>预定义变量</li> <li>环境变量</li></ul> <h3 id=\\\"用户自定义变量\\\"><a href=\\\"#用户自定义变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 用户自定义变量</h3> <ul><li>在shell编程种通常使用全大写变量，方便识别\\ne.g.  COUNT=1</li> <li>变量的调用：在变量前加$\\ne.g.  echo $HOME</li> <li>Linux shell/bash从右向左赋值(变量赋值的时候不用加$，变量调用的时候加$)\\ne.g. Y=y\\nX=$Y\\necho $X\\ny</li> <li>使用unset命令删除变量的赋值\\ne.g. Z=hello\\necho $Z\\nhello\\nunset Z\\necho $Z\\n<img src=\\\"https://ws1.sinaimg.cn/large/006DGX4tly1fzr0fisserj30ec03pwfp.jpg\\\" alt></li></ul> <h3 id=\\\"位置变量\\\"><a href=\\\"#位置变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 位置变量</h3> <ul><li>$0 与键入的明了了行一样，包含脚本文件名</li> <li>$1,$2,.....$9 分别包含第一个到第九个命令行参数</li> <li></li></ul> <h3 id=\\\"环境变量\\\"><a href=\\\"#环境变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 环境变量</h3> <p>显示所有的环境变量的命令: export 或 env。\\n常用shell环境变量：</p> <ul><li>$HOME: /etc/passwd文件种列出的用户主目录</li> <li>$IFS: Internal Field Separator,默认为空格，Tab及换行符</li> <li>$PATH: shell默认搜索路径</li> <li>$PS1,$PS2：默认提示符($)及换行提示符(&gt;)</li> <li>$TERM: 终端类型，常用的有vt100，ansi，vt200，xterm等。</li></ul> <h2 id=\\\"功能语句\\\"><a href=\\\"#功能语句\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 功能语句</h2> <p>shell程序与语句</p> <ul><li>shell程序由0或多个shell语句构成。shell语句包括三类：说明性语句，功能性语句和结构性语句。</li></ul> <ol><li>说明性语句:\\n以#开头到该行结束，不被解释执行。</li> <li>功能性语句：\\n任意的shell命令，用户程序或其他的shell程序。</li> <li>结构性语句:\\n条件测试语句、多路分支语句、循环语句、循环控制语句等。</li></ol> <h3 id=\\\"说明性语句-注释行\\\"><a href=\\\"#说明性语句-注释行\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 说明性语句(注释行)</h3> <ul><li>注释行可以出现在程序中的开始位置，既可以单独占用一行，也可以接在执行语句的后面。以#开始到所在行的行尾部分，都不被解释执行。e.g.</li></ul> <div class=\\\"language-bash extra-class\\\"><pre class=\\\"language-bash\\\"><code><span class=\\\"token shebang important\\\">#!/bin/bash</span>\\n<span class=\\\"token comment\\\">#</span>\\n<span class=\\\"token comment\\\"># 本程序说明</span>\\n<span class=\\\"token comment\\\">#</span>\\ncommand_1  <span class=\\\"token comment\\\">#command_1的语句说明</span>\\n<span class=\\\"token punctuation\\\">..</span><span class=\\\"token punctuation\\\">..</span><span class=\\\"token punctuation\\\">..</span>\\ncommand_n  <span class=\\\"token comment\\\">#command_n的语句说明</span>\\n</code></pre></div><h3 id=\\\"常用功能性语句-命令\\\"><a href=\\\"#常用功能性语句-命令\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 常用功能性语句(命令)</h3> <ul><li>read从标准输入读取一行，并赋值给后面的变量，其语法为：</li></ul> <div class=\\\"language-bash extra-class\\\"><pre class=\\\"language-bash\\\"><code><span class=\\\"token function\\\">read</span> var\\n</code></pre></div><p>把读入的数据全部赋给var</p> <div class=\\\"language-bash extra-class\\\"><pre class=\\\"language-bash\\\"><code><span class=\\\"token function\\\">read</span> var1 var2 var3\\n</code></pre></div><p>把读入行中的第一个单词(word)赋值给var1，第二个单词赋值给var2，......把其余所有的词赋值给最后一个变量。</p> <ul><li>如果执行read语句时标准输入无数据，则程序在此停留等等候，直到数据的到来或被终止执行。</li></ul>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}