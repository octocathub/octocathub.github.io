{"remainingRequest":"/home/bingyu/vue/node_modules/vue-loader/lib/index.js??ref--1-1!/home/bingyu/vue/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/home/bingyu/vue/docs/3-Linux/3-2-Shell.md?vue&type=template&id=6344a681&","dependencies":[{"path":"/home/bingyu/vue/docs/3-Linux/3-2-Shell.md","mtime":1549619620543},{"path":"/home/bingyu/vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/home/bingyu/vue/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"shell编程\"><a class=\"header-anchor\" href=\"#shell编程\" aria-hidden=\"true\">#</a> Shell编程</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\" aria-hidden=\"true\">#</a> 概述</h2>\n<p>常用的shell有Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh), 各有优缺点。Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。</p>\n<blockquote>\n<p>此处学习的为bash shell</p>\n</blockquote>\n<h2 id=\"shell脚本的实质\"><a class=\"header-anchor\" href=\"#shell脚本的实质\" aria-hidden=\"true\">#</a> shell脚本的实质</h2>\n<ul>\n<li>shell脚本语言是解释型语言</li>\n<li>shell脚本的实质-shell命令的有序集合</li>\n</ul>\n<h2 id=\"为什么要使用-filename-sh-行shell脚本呢？\"><a class=\"header-anchor\" href=\"#为什么要使用-filename-sh-行shell脚本呢？\" aria-hidden=\"true\">#</a> 为什么要使用 <code>./filename.sh</code> 行shell脚本呢？</h2>\n<p>普通的shell命令会从标准路径中进行查询，可以通过 echo $PATH 来查询，如果从这些标准路径中查询不到命令，那么就认为是错误的，即是提示命令找不到。所以需要使用 ./</p>\n<h2 id=\"shell变量\"><a class=\"header-anchor\" href=\"#shell变量\" aria-hidden=\"true\">#</a> shell变量</h2>\n<p>shell允许用户建立变量存储数据，但不支持数据类型(整型、字符、浮点型)，将任何赋给变量的值都解释为一串字符。\n以$开头的字符在shell中会被解释为变量。\n<strong>细节问题</strong>：</p>\n<ol>\n<li>没有类型</li>\n<li>没有空格作为分隔符(与C语言不同，C语言对空格不做任何编译)，即&quot;count = 1&quot;为错误的。赋值的时候等号的两边都没有空格。\ne.g.</li>\n</ol>\n<!--beforebegin--><div class=\"language-bash extra-class\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code>count<span class=\"token operator\">=</span>1\n<span class=\"token keyword\">echo</span> <span class=\"token variable\">$count</span>\nDATE<span class=\"token operator\">=</span><span class=\"token string\">'date'</span>\n<span class=\"token keyword\">echo</span> <span class=\"token variable\">$DATE</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>shell有以下4种变量：</p>\n<ul>\n<li>用户自定义变量</li>\n<li>位置变量即命令行参数</li>\n<li>预定义变量</li>\n<li>环境变量</li>\n</ul>\n<h3 id=\"用户自定义变量\"><a class=\"header-anchor\" href=\"#用户自定义变量\" aria-hidden=\"true\">#</a> 用户自定义变量</h3>\n<ul>\n<li>在shell编程种通常使用全大写变量，方便识别\ne.g.  COUNT=1</li>\n<li>变量的调用：在变量前加$\ne.g.  echo $HOME</li>\n<li>Linux shell/bash从右向左赋值(变量赋值的时候不用加$，变量调用的时候加$)\ne.g. Y=y\nX=$Y\necho $X\ny</li>\n<li>使用unset命令删除变量的赋值\ne.g. Z=hello\necho $Z\nhello\nunset Z\necho $Z\n<img src=\"https://ws1.sinaimg.cn/large/006DGX4tly1fzr0fisserj30ec03pwfp.jpg\" alt=\"\"></li>\n</ul>\n<h3 id=\"位置变量\"><a class=\"header-anchor\" href=\"#位置变量\" aria-hidden=\"true\">#</a> 位置变量</h3>\n<ul>\n<li>$0 与键入的明了了行一样，包含脚本文件名</li>\n<li>$1,$2,.....$9 分别包含第一个到第九个命令行参数</li>\n<li></li>\n</ul>\n<h3 id=\"环境变量\"><a class=\"header-anchor\" href=\"#环境变量\" aria-hidden=\"true\">#</a> 环境变量</h3>\n<p>显示所有的环境变量的命令: export 或 env。\n常用shell环境变量：</p>\n<ul>\n<li>$HOME: /etc/passwd文件种列出的用户主目录</li>\n<li>$IFS: Internal Field Separator,默认为空格，Tab及换行符</li>\n<li>$PATH: shell默认搜索路径</li>\n<li>$PS1,$PS2：默认提示符($)及换行提示符(&gt;)</li>\n<li>$TERM: 终端类型，常用的有vt100，ansi，vt200，xterm等。</li>\n</ul>\n<h2 id=\"功能语句\"><a class=\"header-anchor\" href=\"#功能语句\" aria-hidden=\"true\">#</a> 功能语句</h2>\n<p>shell程序与语句</p>\n<ul>\n<li>shell程序由0或多个shell语句构成。shell语句包括三类：说明性语句，功能性语句和结构性语句。</li>\n</ul>\n<ol>\n<li>说明性语句:\n以#开头到该行结束，不被解释执行。</li>\n<li>功能性语句：\n任意的shell命令，用户程序或其他的shell程序。</li>\n<li>结构性语句:\n条件测试语句、多路分支语句、循环语句、循环控制语句等。</li>\n</ol>\n<h3 id=\"说明性语句-注释行\"><a class=\"header-anchor\" href=\"#说明性语句-注释行\" aria-hidden=\"true\">#</a> 说明性语句(注释行)</h3>\n<ul>\n<li>注释行可以出现在程序中的开始位置，既可以单独占用一行，也可以接在执行语句的后面。以#开始到所在行的行尾部分，都不被解释执行。e.g.</li>\n</ul>\n<!--beforebegin--><div class=\"language-bash extra-class\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># 本程序说明</span>\n<span class=\"token comment\">#</span>\ncommand_1  <span class=\"token comment\">#command_1的语句说明</span>\n<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\ncommand_n  <span class=\"token comment\">#command_n的语句说明</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"常用功能性语句-命令\"><a class=\"header-anchor\" href=\"#常用功能性语句-命令\" aria-hidden=\"true\">#</a> 常用功能性语句(命令)</h3>\n<ul>\n<li>read从标准输入读取一行，并赋值给后面的变量，其语法为：</li>\n</ul>\n<!--beforebegin--><div class=\"language-bash extra-class\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code><span class=\"token function\">read</span> var\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>把读入的数据全部赋给var</p>\n<!--beforebegin--><div class=\"language-bash extra-class\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code><span class=\"token function\">read</span> var1 var2 var3\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>把读入行中的第一个单词(word)赋值给var1，第二个单词赋值给var2，......把其余所有的词赋值给最后一个变量。</p>\n<ul>\n<li>如果执行read语句时标准输入无数据，则程序在此停留等等候，直到数据的到来或被终止执行。</li>\n</ul>\n</div>\n",null]}