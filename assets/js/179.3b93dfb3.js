(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{600:function(t,a,s){"use strict";s.r(a);var n=s(13),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"mysql数据库中的各种锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql数据库中的各种锁"}},[t._v("#")]),t._v(" Mysql数据库中的各种锁")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/qq_35642036/article/details/89554721/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/qq_35642036/article/details/89554721/"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。")]),t._v(" "),s("p",[t._v("MySQL大致可归纳为以下3种锁：")]),t._v(" "),s("p",[t._v("表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般")]),t._v(" "),s("p",[t._v("在使用MyIsam时，我们只可以使用表级锁，而MySQL的表级锁有两种模式：")]),t._v(" "),s("p",[t._v("表共享锁（Table Read Lock）和表独占写锁（Table Write Lock），他们在工作时表现如下：")]),t._v(" "),s("p",[t._v("对某一个表的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；\n对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；\nMyISAM表的读操作和写操作之间，以及写操作之间是串行的。\n当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。")]),t._v(" "),s("h2",{attrs:{id:"如何加表锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何加表锁"}},[t._v("#")]),t._v(" 如何加表锁")]),t._v(" "),s("p",[t._v("MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。")]),t._v(" "),s("p",[t._v("给MyISAM表显式加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表order_detail，其中记录有订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("total"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" orders"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("subtotal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" order_detail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LOCK")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),t._v(" orders "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("local")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("order_detail "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("local")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("total"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" orders"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("subtotal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" order_detail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Unlock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("要特别说明以下两点内容。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("上面的例子在LOCK TABLES时加了‘local’选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾插入记录")])]),t._v(" "),s("li",[s("p",[t._v("在用LOCKTABLES给表显式加表锁时，必须同时取得所有涉及的表的锁。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，而不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MySQL会一次性获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。另外，MySQL支持锁升级，即在条件满足时，允许从表共享锁升级为表独占锁。")])])]),t._v(" "),s("p",[t._v("一个session使用LOCK TABLE 命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。")]),t._v(" "),s("p",[t._v("当使用LOCK TABLE时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁多少次，否则也会出错！")]),t._v(" "),s("h2",{attrs:{id:"并发锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发锁"}},[t._v("#")]),t._v(" 并发锁")]),t._v(" "),s("p",[t._v("在一定条件下，MyISAM也支持查询和操作的并发进行。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。\n")])])]),s("p",[t._v("当concurrent_insert设置为0时，不允许并发插入。\n当concurrent_insert设置为1时，如果MyISAM允许在一个读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。\n当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾插入记录，都允许在表尾并发插入记录。\n可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将concurrent_insert系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIONMIZE TABLE语句来整理空间碎片，收集因删除记录而产生的中间空洞。")]),t._v(" "),s("h2",{attrs:{id:"myisam的锁调度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#myisam的锁调度"}},[t._v("#")]),t._v(" MyISAM的锁调度")]),t._v(" "),s("p",[t._v("前面讲过，MyISAM存储引擎的读和写锁是互斥，读操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。")]),t._v(" "),s("p",[t._v("通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。\n通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。\n通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。\n虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。")]),t._v(" "),s("p",[t._v("另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。")]),t._v(" "),s("p",[t._v("上面已经讨论了写优先调度机制和解决办法。这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题。因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。")]),t._v(" "),s("h2",{attrs:{id:"innodb锁问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb锁问题"}},[t._v("#")]),t._v(" InnoDB锁问题")]),t._v(" "),s("p",[t._v("InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。")]),t._v(" "),s("p",[t._v("行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。")]),t._v(" "),s("h3",{attrs:{id:"_1-事务-transaction-及其acid属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务-transaction-及其acid属性"}},[t._v("#")]),t._v(" 1.事务（Transaction）及其ACID属性")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。\n")])])]),s("p",[t._v("原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。\n一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。\n隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。\n持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。")]),t._v(" "),s("h3",{attrs:{id:"_2-并发事务带来的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发事务带来的问题"}},[t._v("#")]),t._v(" 2.并发事务带来的问题")]),t._v(" "),s("p",[t._v("相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题")])]),t._v(" "),s("li",[s("p",[t._v("脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。")])]),t._v(" "),s("li",[s("p",[t._v("不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。")])]),t._v(" "),s("li",[s("p",[t._v("幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。")])])]),t._v(" "),s("h2",{attrs:{id:"innodb的行锁模式及加锁方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb的行锁模式及加锁方法"}},[t._v("#")]),t._v(" InnoDB的行锁模式及加锁方法")]),t._v(" "),s("p",[t._v("InnoDB实现了以下两种类型的行锁。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("共享锁（s）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。xxx lock in share mode")])]),t._v(" "),s("li",[s("p",[t._v("排他锁（Ｘ）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。xxx for update\n另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。")])])]),t._v(" "),s("p",[t._v("意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。")]),t._v(" "),s("p",[t._v("意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。")])])}),[],!1,null,null,null);a.default=e.exports}}]);