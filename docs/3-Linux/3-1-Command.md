# 基础命令
## deb软件包管理

### deb软件包管理机制
- Debian Linux首先提出"软件包"的管理机制---Deb软件包
将应用程序的二进制文件、配置文档、man/info帮助页面等文件合并打包在一个文件中，用户使用软件包管理器直接操作软件包，完成获取、安装、卸载、查询等操作。
- 由于系统中软件包之间复杂的依赖关系，Debian Linux又开发出了APT软件包管理器。
APT软件包管理器的两大亮点：
1. 检查和修复软件包依赖关系
2. 利用Internet网络帮助用户主动获取软件包。
### 软件包的类型
1. Ubuntu有两种类型的软件包：二进制软件包(deb)和源码包(deb-src)。
- 二进制软件包(binary packages):包含可执行文件、库文件、配置文件、man/info页面、版权声明和其他文档。

- 源码包(source packages):包含软件源代码、版本修改说明、构建指令以及编译工具等。先由tar工具归档为.tar.gz文件，然后再打包成.dsc文件。

2. 在用户不确定一个软件包类型时，可以使用file命令查看文件类型。

### 软件包的命名
- 软件包的命名遵循以下约定：
filename_version_reversion_architecture.deb
(软件包名称_软件版本_修订版本_体系架构)

### 软件包管理工具分类
- 根据用户交互方式的不同，可以将常见的软件包管理工具分为三类。
类别  常见工具举例  描述
命令行  dpkg-deb、dpkg、apt  在命令行模式下完成软件包管理任务。为完成软件包的获取、查询、软件包依赖性检查、安装、卸载等任务，需要使用各自不同的命令

文本窗口界面  dselect、aptitude、tasksel  在文本窗口模式中，使用窗口和菜单可以完成软件包管理任务

图形界面  synaptic  在X-Window图形桌面界面环境中运行，具有更好的交互性、可读性、易用性等特点。

Tips：在不考虑依赖关系和网络连接的情况下，我们可以使用dpkg来安装软件包，需要你自己处理依赖关系。
### dpkg相关命令
- dpkg -i <package_filename_version_reversion_architecture.deb>  安装一个在本地文件系统上存在的Debian软件包
- dpkg -r <package_filename>  移除一个已经安装的软件包
- dpkg -P <package_filename>  移除已安装软件包及配置文件
- dpkg -L <package_filename>  列出安装的软件包清单
- dpkg -s <package_filename>  显出软件包的安装状态
Tips：当我们没有网络的时候，我们就可以使用dpkg命令进行安装。但是前提是在我们的系统上已经有了该软件包。当我们想了解软件包的安装位置、帮助页眉、配置文件的目录等信息的时候，我们需要使用-L选项。
-s 选项来查询安装状态(即是否安装，以及该软件的相关信息描述)

### APT工作原理
- Ubuntu采用 **集中式的软件仓库机制**，将各式各样的软件包分门别类的存放在软件仓库中，进行有效的组织和管理。然后，将软件仓库置于许许多多的镜像服务器中，并保持一致。因此，对于用于，这些镜像服务器就是他们的软件源(reposity)。
- 在Ubuntu系统中，使用软件源配置文件 `/etc/apt/sources.list` 列出最合适访问的镜像站点地址。
- 软件源配置文件只是告知Ubuntu系统可以访问的镜像站点地址。但那些镜像站点都拥有什么软件资源并不清楚。若是每安装一个软件包，就在服务器上寻找一遍，效率是很低的。因此，就有必要为这些软件资源列个清单(建立索引文件)，以便本地主机查询。这就是APT软件包管理器的工作原理。
### 软件源配置文件
- /etc/apt/sources.list。本质就是一个普通的文本文件，可以在超级管理员授权下，使用任何文本编辑器进行编辑。在该文件中，添加的软件源镜像站点称为一个配置项，并遵循以下格式：
```
DebType AddressType://Hostaddress/Ubuntu Distribution Component1 Component2......
deb http://cn.archive.ubuntu.com/ubuntu/ feisty main restricted universe multiverse
```
根据软件包的开发组织对该软件的支持程度，以及遵从的开源程度，划分为如下四类：
- 核心(main):官方维护的开源软件。是由Ubuntu官方完全支持的软件，包括大多数流行的、稳定的开源软件，是Ubuntu默认安装是基本软件包。
- 公共(universe):社区维护的开源软件，是由Ubuntu社区的计算机爱好者维护的软件。这些软件包没有安全升级的保障。用户在使用时，需要考虑这些软件包存在的不稳定性。
- 受限(restricted):官方维护的非开源软件，是专供特殊用途，而且没有自由软件版权，不能直接修改软件，但依然被Ubuntu团队支持的软件。
- 多元化(multiverse):非Ubuntu官方维护的非开源软件，用户使用这些软件包时，需要特别注意版权问题。

### 刷新软件源
- 修改了配置文件-/etc/apt/sources.list,目的只是告知软件源镜像站点的地址。但那些所指向的镜像站点所具有的软件资源并不清楚，需要将这些资源列个清单，以便本地主机知晓可以申请哪些资源。
- 使用"apt-get update"命令会扫描每一个软件源服务器，并为该服务器所具有软件包资源建立索引文件，存放在本地的/var/lib/apt/lists/目录中。

### 管理软件包
- 在Ubuntu Linux中，通常使用apt-get命令管理软件包，只需告知软件包名字，就可以自动完成软件包的获取、安装、编译和卸载，以及检查软件包依赖关系。
- apt-get命令提供了一个软件包管理的命令行平台。在这个平台上使用更丰富的子命令，完成具体的管理任务。
``` bash
apt-get subcommands [-d | -f | -m | -q | --purge | --reinstall | -b | -s | -y | -u | -v] pkg
```
subcommands(子命令)表格
子命令 描述
update 下载更新软件包列表信息
upgrade 将系统中所有软件包升级到最新的版本
install 下载所需软件包并进行安装配置
remove 卸载软件包
autoremove 将不满足依赖关系的软件包自动卸载
source 下载源码包
build-dep 将源码包构建所需的编译环境
dist-upgrade 发布版升级
dselect-upgrade 根据dselect的选择来进行软件包升级
clean 删除缓存区中所有已下载的包文件
autoclean  删除缓存区中老版本的已下载的包文件
check 检查系统中依赖关系的完整性

选项表格
选项 描述
-d 仅下载软件包，而不安装或解压
-f 修复系统中存在的软件包依赖性问题
-m 当发现缺少关联软件包时，仍试图继续执行
-q 将输出作为日志保留，不获取命令执行进度
--purge 与remove子命令一起使用，完全卸载软件包
--reinstall 与install子命令一起使用，重新安装软件包
-b 在下载完源码包后，编译生成相应的软件包
-s 不做实际操作，只是模拟命令执行结果
-y 对所有询问都做肯定的回答，apt-get不再进行任何提示
-u 获取已升级的软件包列表
-h 获取帮助信息
-v 获取apt-get版本号

### 修复软件包依赖关系
- 如果由于故障而中断软件安装过程，可能会造成关联的软件包只有部分安装。之后，用户就会发现该软件既不能重装也不能删除。
- 作为组合命令，下面前者用于检查软件包依赖关系，后者 用于修复依赖关系。
``` bash
apt-get check   apt-get -f install
```
- 在处理依赖关系上，apt-get会自动下载并安装具有依赖关系(depends)的软件包，但不会处理与安装软件包存在推荐(recommends)和建议(suggests)关系的软件包。
![](./img/apt-check.png)

### 安装软件包
- 在准备好软件源并联通网络后，用户只需告知软件的名称，"apt-get install"命令就可以轻松完成整个安装过程，而无须考虑软件包的版本、优化级、依赖关系等。
- 使用"apt-get install"下载软件包大体分为四步：
1. 扫描本地存放的软件包更新列表(由apt-get update命令刷新更新列表)，找到最新版本的软件包。
2. 进行软件包依赖关系检查，找到支持该软件正常运行的所有软件包。
3. 从软件源所指的镜像站点中，下载相关软件包。
4. 解压软件包，并自动完成应用程序的安装和配置。

### 重新安装软件包
- 当用户不小心损坏了已安装的软件包(比如不小心删除了软件的配置文件或下载安装软件时突然断网，导致软件包不完整)，而需要修复。或者，希望重新安装软件包中某些文件的最新版本，可以重新安装软件包。
- 此时我们不需要卸载或者删除该软件，只需要重新安装即可。其实是覆盖了原来的软件。
``` bash
sudo apt-get install package --reinstall
```

### 卸载软件包
- 不完全卸载
"apt-get remove package_filename"会关注那些与被删除的软件包相关的其他软件包，删除一个软件包时，将会连带删除与该软件包有依赖关系的软件包。
- 完全卸载
"apt-get --purge remove package_filename"命令在卸载软件包文件的同时，还删除该软件包所使用的配置文件。

### 清理软件包缓冲区
- `/var/cache/apt/archives/` (archive:存档，档案室)----软件包缓冲区是为了缓存下载的软件包，我们从互联网上使用 `apt-get install` 下载的软件包都会被默认存储该目录下。但是该缓冲区会随着你下载安装的软件逐渐变大，当我们的系统容量不够用，或者不需要这些以及缓存的软件包时，我们即可以何使用clean选项进行清理。
以下是缓冲区部分截图：
注：此目录下还包含了partial目录和lock文件。这两个文件不会被清理掉，其他的都会被清理掉。
![](./img/apt-clean.png)
- 如果用户认为软件包缓冲区中的文件没有任何价值了，有必要删除全部下载的软件包。可以使用"apt-get clean"清理整个软件包缓冲区，除了lock锁文件和partial目录。
- 按照依赖关系清理缓冲区中多余的软件包，如果用户希望缓冲区中只保留最新版本的软件包，多余版本全部清除，可以使用"apt-get autoclean"命令。

### 查询软件包信息
- 使用apt-cache命令完成查询软件源和软件包的相关信息
``` bash
apt-cache subcommands [-p | -s | -q | -i | -c | -h] package_filename
$ apt-cache show vim
```
![](./img/apt-show.png)
(subcommands)子命令 描述
showpkg 获取二进制软件包的常规描述信息
showrc 获取源码包的详细描述信息
show 获取二进制软件包的详细描述信息
stats 获取软件源的基本统计信息
search 根据正则表达式检索软件包
depends 获取该软件包的依赖信息
rdepends 获取所有依赖于该软件包的软件包
pkgnames 列出所有已安装软件包的名字
policy 获取软件包当前的安装状态

- 使用"apt-cache show"命令获取指定软件包的详细信息，包括软件包安装状态、优先级、适用架构、版本、存在依赖关系的软件包，以及功能描述。该命令可以同时显现多个软件包的详细信息。
- 使用"apt-cache policy"可以获取软件包当前的安装状态，与"dpkg -s"类似，但是貌似"dpkg -s"可以显示更多的信息(其实为状态信息，而不仅仅是安装状态信息)。
![](./img/apt-policy.png)
- 如果用户仅想了解某个软件包依赖于哪些软件包，可以使用"apt-cache depends"命令
- 如果用户仅想了解某个软件包被哪些软件包所依赖，可以使用"apt-cache rdepends"命令。

## shell基本命令
### 简介
- 用户在命令行提示符下键入命令文本，开始与shell进行交互
- 接着，shell将用户的命令或按键转化成内核所能够理解的指令
- 控制操作系统做出响应，直到控制相关硬件设备
- 然后，shell将输出结果通过shell提交给用户

### shell命令格式
- shell提示符标识了命令行的开始。用户在提示符后面输入一条命令并按enter键，完成向系统提交指令。
通常shell命令提示符采用以下的格式：
```
username@hostname:direction$
用户名    主机名   目录名
```
  - username:用户名，显示当前登陆用户的账户名
  - hostname:主机名，显示登陆的主机名，例如若远程登陆后，则显示登陆的主机名
  -direction:目录名，显示昂前所处的路径，当在根目录下显示为"/",当在用户主目录下显示为"~"
- 通常一个命令包含三个要素：命令名称、选项、参数。命令名称是必须的，选项与参数都可能使可选项。命令格式如下所示：
``` bash
$ command [-options] argument1 argument2 ...
 指令       选项     参数1      参数2
```
  - $:shell提示符，如果当前用户为超级用户，提示符为"#"，其他用户的提示符均为"$"
  - command:命令名称，shell命令或程序，严格区分大小写
  - options:命令选项，用于改变命令执行动作的类型，由"-"引导，可以同时带有多个选项
  - argument:命令参数，指出命令作用的对象或目标，有的命令允许带多个参数
- 一条命令的三要素之间用空格隔开
- 若将多个命令在一行书写，用分号(;)将各命令隔开
![](./img/command-many.png)
- 如果一条命令不能在一行写完， 在行尾使用反斜杠(\\)表明该条命令未结束

### 命令行操作
- 补齐命令与文件名
  - 在使用shell命令时，很多用户会经常遇到命令或文件名没有记全的情况。bash shell的命令和文件名补齐功能会帮助用户。在输入命令或文件名的前几个字符后，按Tab或Esc键自动补齐剩余没有输入的字符串
  - 如果存在多个命令或文件有相同前缀，shell将列出所有相同前缀的命令或文件。shell给出的提示信息，帮助用户回忆和完成输入。之后等待用户输入足够的字符。
  - 需要说明的是，连续按两下Tab或Esc键，用于命令补齐；按一下Tab键，用于文件名补齐
- 查询命令历史
  - 用户在shell下的操作是有很大连续性的，曾经输入的命令可能需要多次使用。当用户在操作中发现问题，需要查看曾经执行过的操作。bash将用户曾经输入的命令序列保存在一个命令历史表中。按"↑"键和"↓"键，便可查询命令历史
  - bash shell还提供了history命令。该命令将命令历史表按列表形式，从记录号1开始，一次性全部显示出来。
  ``` bash
  history [numberline]
  ```
  - 显示history只能记录有限条的历史命令，默认保留500条命令
  - bash shell将历史命令容量保存在环境变量HISTSIZE中
    - 使用"echo $HISTSIZE"查看当前历史命令容量
    - 通过直接赋值的方法，修改这个环境变量(但是这个只是临时的，当我们再次打开终端的时候，会发现仍然没有改变这个变量值，如果要永久修改这个值，我们需要修改.bashrc这个配置文件，`vim .bashrc`)
![](./img/history.png)

## shell命令中的特殊字符

### 通配符
- 当需要用 **命令** 处理一组文件(批量化处理文件)，例如：file1.txt、file2.txt、file3.txt......，用户不必一一输入文件名，可以使用shell通配符。shell命令的通配符含义如下表
通配符 含义 实例
星号(\*) 匹配任意长度(0个或多个)的字符串 用file_*.txt,匹配file_wang.txt、file_Lee.txt、file3_Liu.txt

问号(?) 匹配一个长度的字符 用file_?.txt，匹配file_1.txt、file_2.txt、file_3.txt

方括号([...]) 匹配其中指定的一个字符 用file_[otr].txt，匹配file_o.txt、file_r.txt和file_t.txt

方括号([-]) 匹配指定的一个字符的范围 用file_[a-z].txt，匹配file_a.txt、file_b.txt，直到file_z.txt

方括号([^...]) 除了其中指定的字符，均可匹配 用file_[^otr].txt，除了file_o.txt、file_r.txt和file_t.txt的其他文件(但是这里只能匹配一个字符，多个字符仍然不能匹配，且[^1-9]可以匹配除了1-9之外的其他任意一个字符)

### 管道
- 管道可以把一系列命令连接起来，意味着第一个命令的输出将作为第二个命令的输入，通过管道传递给第二个命令，第二个命令的输出又将作为第三个命令的输入，以此类推。就像通过使用"|"符连成了一个管道。
``` bash
$ ls /usr/bin | wc -w
1813
```
以上操作中，借助管道"|"，将ls的输出直接作为wc命令的输入。使用管道可以巧妙的将一些命令联合使用，得到单个命令所无法实现的效果。例如使用以上的命令组合，得到的是/usr/bin目录下的文件的个数。

### 输入输出重定向
- 输入/输出重定向是改变shell命令或程序默认的标准输入/输出目标，重新定向到新的目标。
- Linux中默认的标准输入定义为键盘，标准输出定义为终端窗口。
用户可以为当前操作改变输入或输出，迫使某个特定命令的输入或输出来源为外部文件。

重定向符 含义 实例
\>file 将file文件重定向为输出源，新建模式 ls /usr>Lsoutput.txt文件中，若有同名文件将被删除
\>>file 将file文件重定向为输出源，追加模式 ls /usr>>Lsoutput.txt，文件已有内容后
<file 将file重定向为输入源 将file1中的内容作为输入
2>或&> 将由命令产生的错误信息输入到文件中 ls noexistingfile.txt 2> err.log,使用ls命令的文件时，将系统错误提示保存在err.log文件
Tips:2>与&>的区别，2>只能输入错误信息，不能输入正确信息；而&>可以输入错误信息和正确信息。而\>和\>>只能输入正确信息。而2>和&>也有追加模式，分别为2>>,&>>。


### 命令置换
- 命令替换是将一个命令的输出作为另一个命令的参数。命令格式如下所示。
- 命令置换经常用于shell脚本中。
- 命令置换包含有"`"和'$()'两种。
e.g.
``` bash
bingyu@ubuntu:~$ echo "Today is date"
Today is date
bingyu@ubuntu:~$ echo "Today is `date`"
Today is Wed Feb  6 15:44:01 CST 2019
bingyu@ubuntu:~$ echo "Now is $(date "+%Y-%m-%d %H:%M")"
Now is 2019-02-06 15:44
```
![](https://ws1.sinaimg.cn/large/006DGX4tly1fzwr0t9eh5j30m5034abq.jpg)

1. 其中，命令 command2 的输出将作为命令 command1 的参数。需要注意，命令置换的单引号为 ESC 键下方的“`”键
``` bash
command1 `command2`
```
2. pwd 命令用于显示当前目录的绝对路径。在上面的命令行中，使用命令置换符，将pwd 的运行结果作为 ls 命令的参数。最终，命令执行结果是显示当前目录的文件内容。
``` bash
 linux@ubuntu:~$ls `pwd` Desktop Examples historycommandlist mywork
```

## Linux shell命令




## Linux shell脚本编程

## Linux C语言高级编程

## Makefile

